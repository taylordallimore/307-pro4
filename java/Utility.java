import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

public class Utility {

  /**
   * Calculate the Euclidean distance between two VRP nodes
   * 
   * @param node1 the first VRP node
   * @param node2 the second VRP node
   * @return the Euclidean distance between node1 and node2
   */
  public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
    double X = node1.getX() - node2.getX();
    double Y = node1.getY() - node2.getY();
    double distance = Math.sqrt(X * X + Y * Y);
    return distance;
  }

  /**
   * Calculate the total cost of a VRP solution under a VRP instance.
   * The total cost is the sum of all the Euclidean distance between adjacent
   * nodes in the routes.
   * 
   * @param solution the VRP solution.
   * @param instance the VRP instance.
   * @return the total cost of the solution.
   */
  public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
    double cost = 0;
    VRPNode depot = instance.getDepot();
    List<List<Integer>> routes = solution.getRoutes();
    Map<Integer, VRPNode> nodes = instance.getNodes();
    for (List<Integer> route : routes) {
      cost += calculateEuclideanDistance(depot, nodes.get(route.get(0)));
      for (int i = 1; i < route.size(); i++) {
        int current = route.get(i);
        int previous = route.get(i - 1);
        cost += calculateEuclideanDistance(nodes.get(previous), nodes.get(current));
      }
      cost += calculateEuclideanDistance(nodes.get(route.get(route.size() - 1)), depot);
    }
    return cost;
  }

  /**
   * Generate a VRP solution for a VRP instance using the nearest neighbour
   * heuristic.
   * 
   * @param instance the VRP instance.
   * @return the VRP solution generated by the nearest neighbour heuristic.
   */
  public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
    List<List<Integer>> routes = new ArrayList<>();
    List<Integer> route = new ArrayList<>();
    List<VRPNode> frontier = new ArrayList<>(instance.getNodes().values());
    while (!frontier.isEmpty()) {
      VRPNode current = instance.getDepot();
      double cap = instance.getCapacity();
      while (true) {
        frontier.remove(current);
        VRPNode nearest = getNearest(current, frontier, cap);
        if (nearest == null) {
          break;
        }
        cap -= nearest.getDemand();
        current = nearest;
        route.add(current.getID());
      }
      routes.add(route);
      route = new ArrayList<>();
    }
    return new VRPSolution(routes);
  }

  /**
   * Generate a VRP solution for a VRP instance using the savings heuristic.
   * 
   * @param instance the VRP instance.
   * @return the VRP solution generated by the savings heuristic.
   */
  public static VRPSolution savingsHeuristic(VRPInstance instance) {
    List<List<Integer>> routes = new ArrayList<List<Integer>>();
    for (VRPNode node : instance.getNodes().values()) {
      if (node.getID() == 1)
        continue;
      List<Integer> route = new ArrayList<>();
      route.add(node.getID());
      routes.add(route);
    }
    double[][] savings = new double[instance.getNodes().size() + 1][instance.getNodes().size() + 1];
    for (double[] line : savings)
      Arrays.fill(line, 0);
    for (int i = 2; i < instance.getNodes().size(); i++) {
      for (int j = i + 1; j < instance.getNodes().size() + 1; j++) {
        VRPNode node1 = instance.getNodes().get(i);
        VRPNode node2 = instance.getNodes().get(j);
        savings[i][j] = calculateEuclideanDistance(node1, instance.getDepot())
            + calculateEuclideanDistance(instance.getDepot(), node2) - calculateEuclideanDistance(node1, node2);
        savings[j][i] = savings[i][j];
      }
    }
    while (true) {
      List<Integer> bestMerge = merge(routes, savings, instance);
      if (bestMerge == null)
        break;
      for (int i = routes.size() - 1; i >= 0; i--) {
        if (bestMerge.containsAll(routes.get(i)))
          routes.remove(i);
      }
      routes.add(bestMerge);
    }
    return new VRPSolution(routes);
  }
  
  private static List<Integer> merge(List<List<Integer>> routes, double[][] savings, VRPInstance instance) {
    double bestSaving = 0;
    List<Integer> bestMerge = null;
    for (List<Integer> route1 : routes) {
      for (List<Integer> route2 : routes) {
        if (route1 == route2)
          continue;
        double saving = savings[route1.get(route1.size() - 1)][route2.get(0)];
        if (saving <= bestSaving)
          continue;
        List<Integer> merge = new ArrayList<Integer>();
        merge.addAll(route1);
        merge.addAll(route2);
        double total = 0;
        for (int i : merge) {
          total += instance.getNodes().get(i).getDemand();
        }
        if (total > instance.getCapacity())
          continue;
        bestSaving = saving;
        bestMerge = merge;
      }
    }
    return bestMerge;
  }
  
  private static VRPNode getNearest(VRPNode current, List<VRPNode> frontier, double max) {
    VRPNode nearest = null;
    double shortestDistance = Double.MAX_VALUE;
    for (VRPNode node : frontier) {
      if (node.getDemand() > max)
        continue;
      double d = calculateEuclideanDistance(current, node);
      if (d < shortestDistance) {
        shortestDistance = d;
        nearest = node;
      }
    }
    return nearest;
  }

}